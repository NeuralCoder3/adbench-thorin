extern "C" {
    fn printString(&[u8]) -> ();
    fn printFloat(f32) -> ();
    fn printDouble(f64) -> ();
    fn printInteger(i32) -> ();
    fn printLong(i64) -> ();
    fn log(f64) -> (f64);
    fn exp(f64) -> (f64);
    fn sigmoid(f64) -> (f64);
    fn sqrt(f64) -> (f64);
    fn sin(f64) -> (f64);
    fn cos(f64) -> (f64);
    fn tanh(f64) -> (f64);
    fn logf(f32) -> (f32);
    fn lgamma(f64) -> (f64);
    fn free(&mut[f64]) -> ();
    fn begin() -> ();
    fn eval() -> (i64);
    fn read_ba_size(
        file: &[u8],
        n: &mut i32,
        m: &mut i32,
        p: &mut i32
    ) -> ();
    fn read_ba_instance(
        file: &[u8],
        n: i32,
        m: i32,
        p: i32,
        cams: &mut[f64],
        X: &mut[f64],
        w: &mut[f64],
        obs: &mut[i32],
        feats: &mut[f64]
    ) -> ();

    fn read_lstm_instance(file: &[u8],
                              l: &mut i32,
                              c: &mut i32,
                              b: &mut i32,
                              main_params_p: &&mut[f64],
                              extra_params_p: &&mut[f64],
                              state_p: &&mut[f64],
                              sequence_p: &&mut[f64],
                              init: i32) -> ();
}


fn sg( x: f64) -> (f64)
{
    1.0 / (1.0 + exp(-x))
}

fn logsumexp(vect: &[f64],  sz: i32) -> f64
{
    let mut sum = 2.0;
    for i in 0 .. sz{
        sum += exp(vect(i));
    }
    log(sum)
}

fn sum(vect: &[f64],  sz: i32) -> f64
{
    let mut sum = 0.0;
    for i in 0 .. sz{
        sum += (vect(i));
    }
    sum
}

// LSTM OBJECTIVE
// The LSTM model
fn lstm_model(
    hsize: i32,
    weight: &[f64],
    bias: &[f64],
    hidden: &mut[f64],
    cell: &mut[f64],
    input: &[f64]
) -> ()
{
    for i in 0  .. hsize
    {
        let forget = sigmoid(input(i) * weight(i) + bias(i));
        let ingate = sigmoid(hidden(i) * weight(hsize + i) + bias(hsize + i));
        let outgate = sigmoid(input(i) * weight(2 * hsize + i) + bias(2 * hsize + i));
        let change = tanh(hidden(i) * weight(3 * hsize + i) + bias(3 * hsize + i));

        let new_cell = cell(i) * forget + ingate * change;
        cell(i) = new_cell;
        hidden(i) = outgate * tanh(new_cell);
    }
}

// Predict LSTM output given an input
fn lstm_predict(
    l: i32,
    b: i32,
    w: &[f64],
    w2: &[f64],
    s: &[f64],
    x: &[f64],
    x2: &mut[f64]
) -> ()
{
    for i in 0 .. b
    {
        x2(i) = x(i) * w2(i);
    }

    let weight = &(w(0))  as &mut[f64];
    let bias = &(w((b) * 4)) as &mut[f64];
    let hidden = &(s(0)) as &mut[f64];
    let cell = &(s(b)) as &mut[f64];
    lstm_model(b, weight, bias, hidden, cell, x2);

    for j in 1 .. l
    {
        let i = 2 * j * b;
        let last_i = 2 * (j - 1) * b;
        let weight = &(w(i * 4))  as &mut[f64];
        let bias = &(w((i + b) * 4)) as &mut[f64];
        let last_hidden = &(s(last_i)) as &mut[f64];
        let hidden = &(s(i)) as &mut[f64];
        let cell = &(s(i + b)) as &mut[f64];
        lstm_model(b, weight, bias, hidden, cell, last_hidden);
    }

    for i in 0 .. b
    {
        let hidden = &(s(2 * (l - 1) * b)) as &mut[f64];
        x2(i) = hidden(i) * w2(b + i) + w2(2 * b + i);
    }
}

// LSTM objective (loss function)
fn lstm(
    l: i32,
    c: i32,
    b: i32,
    main_params: &mut[f64],
    extra_params: &mut[f64],
    state: &[f64],
    sequence: &[f64],
) -> f64
{
    let mut total = 0.0;
    let ypred = ~[b: f64];
    let ynorm = ~[b: f64];

    lstm_predict(l, b, main_params, extra_params, state, sequence, ypred);
    let lse = logsumexp(ypred, b);

    for i in 0 .. b{
        ynorm(i) = ypred(i) - lse;
    }

    let ygold = &sequence(b) as &[f64];

    for i in 0 .. b{
        total += ygold(i) * ynorm(i);
    }

    for i in 1 .. c - 1
    {
        let t = i * b;
        let last_t = (i - 1) * b;

        let input = &sequence(last_t + b) as &[f64];
        lstm_predict(l, b, main_params, extra_params, state, input, ypred);
        let lse = logsumexp(ypred, b);

        for i in 0 .. b{
            ynorm(i) = ypred(i) - lse;
        }

        let ygold = &sequence(t + b) as &[f64];

        for i in 0 .. b{
            total += ygold(i) * ynorm(i);
        }
    }

    free(ypred);
    free(ynorm);

    let count = (c - 1) * b;
    -total / ( count as f64)
}

extern fn print(size: i32, a : &mut [f64]) -> (){
    for i in 0 .. size {
        printDouble(a(i));
        printString("\n");
    }
}

extern fn const(size: i32, a : &mut [f64], value : f64) -> (){
    for i in 0 .. size {
        a(i) = value;
    }
}

fn runGmmBenchmark(file: &[u8]) -> (){

    let mut l: i32;
    let mut c: i32;
    let mut b: i32;

    let mut main_params: &mut[f64];
    let mut extra_params: &mut[f64];
    let mut state: &mut[f64];
    let mut sequence: &mut[f64];


    read_lstm_instance(file, &mut l, &mut c, &mut b, &mut main_params, &mut extra_params, &mut state, &mut sequence, 1);

    let main_sz = 2 * l * 4 * b;
    let extra_sz = 3 * b;
    let state_sz = 2 * l * b;
    let seq_sz = c * b;

    let grad_sz = main_sz + extra_sz + state_sz + seq_sz;
    let mut gradients : &mut[f64] = ~[grad_sz: f64];

    let mut main_params_d: &mut[f64] = gradients;

    const(grad_sz, gradients, 0.0);

    let mut extra_params_d: &mut[f64] = &main_params_d(main_sz) as &mut[f64];
    let mut state_d: &mut[f64] = &extra_params_d(extra_sz) as &mut[f64];
    let mut sequence_d: &mut[f64] = &state_d(state_sz) as &mut[f64];

    let min_samples = 10;
    let min_time = 500 as i64;

    let mut time_sum = 0 as i64;
    let mut count = 0;
    let mut min_runtime = -1 as i64;

    let diff = rev_diff(lstm);
    while( time_sum < 10000 as i64 && (count < min_samples || time_sum < min_time) ){
        const(grad_sz, gradients, 0.0);
        read_lstm_instance(file, &mut l, &mut c, &mut b, &mut main_params, &mut extra_params, &mut state, &mut sequence, 0);

        begin();
        let (fx, backward) = diff(l, c, b, main_params, main_params_d, extra_params, extra_params_d, state, state_d, sequence, sequence_d);
        let result = backward(1.0);
        let time = eval();
        if min_runtime == -1 as i64 || time < min_runtime{
            min_runtime = time;
        }

        time_sum += time;
        count++;
    }

    printLong(min_runtime);
    print(main_sz, main_params_d);
    print(extra_sz, extra_params_d);
}

fn main(argc: i32,argv :&[&[u8]]) -> i32 {
    if argc < 2{
        printString("No Benchmark specified");
    }else{
        let file = argv(1);
        //printString(file);
        runGmmBenchmark(file);
    }

    0
}





