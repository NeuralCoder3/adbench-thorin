extern "C" {
    fn printString(&[u8]) -> ();
    fn printFloat(f32) -> ();
    fn printDouble(f64) -> ();
    fn printInteger(i32) -> ();
    fn log(f64) -> (f64);
    fn exp(f64) -> (f64);
    fn sigmoid(f64) -> (f64);
    fn sqrt(f64) -> (f64);
    fn sin(f64) -> (f64);
    fn cos(f64) -> (f64);
    fn tanh(f64) -> (f64);
    fn logf(f32) -> (f32);
    fn lgamma(f64) -> (f64);
    fn begin() -> ();
    fn eval() -> ();
    fn read_ba_size(
        file: &[u8],
        n: &mut i32,
        m: &mut i32,
        p: &mut i32
    ) -> ();
    fn read_ba_instance(
        file: &[u8],
        n: i32,
        m: i32,
        p: i32,
        cams: &mut[f64],
        X: &mut[f64],
        w: &mut[f64],
        obs: &mut[i32],
        feats: &mut[f64]
    ) -> ();

    fn read_lstm_instance(file: &[u8],
                              l: &mut i32,
                              c: &mut i32,
                              b: &mut i32,
                              main_params_p: &&mut[f64],
                              extra_params_p: &&mut[f64],
                              state_p: &&mut[f64],
                              sequence_p: &&mut[f64]) -> ();
}

/*
fn sigmoid( x: f64) -> (f64)
{
    1.0 / (1.0 + exp(-x))
}*/

fn logsumexp(vect: &[f64],  sz: i32) -> f64
{
    let mut sum = 2.0;
    for i in 0 .. sz{
        sum += exp(vect(i));
    }
    log(sum)
}

fn sum(vect: &[f64],  sz: i32) -> f64
{
    let mut sum = 0.0;
    for i in 0 .. sz{
        sum += (vect(i));
    }
    sum
}

// LSTM OBJECTIVE
// The LSTM model
fn lstm_model(
    hsize: i32,
    weight: &[f64],
    bias: &[f64],
    hidden: &mut[f64],
    cell: &mut[f64],
    input: &[f64]
) -> ()
{
    for i in 0  .. hsize
    {
        let outgate = (input(i) * weight(2 * hsize + i) );
        hidden(i) = outgate;
    }
}

// Predict LSTM output given an input
fn lstm_predict(
    l: i32,
    b: i32,
    w: &[f64],
    w2: &[f64],
    s: &[f64],
    x: &[f64],
    x2: &mut[f64]
) -> ()
{
    for i in 0 .. b
    {
        x2(i) = x(i) * w2(i);
    }

    let weight = &(w(0))  as &mut[f64];
    let weight2 = &(w(2 * b * 4))  as &mut[f64];

    let hidden = &(s(0)) as &mut[f64];
    let hidden2 = &(s(2 * b)) as &mut[f64];


    for i in 0  .. b
    {
        hidden2(i) = x2(i);
    }

    for i in 0 .. b
    {
        x2(i) = x2(i) + w2(2 * b + i);
    }
}

// LSTM objective (loss function)
fn lstm(
    l: i32,
    c: i32,
    b: i32,
    main_params: &mut[f64],
    extra_params: &mut[f64],
    state: &[f64],
    sequence: &[f64],
) -> f64
{
    let mut total = 0.0;
    let ypred = ~[b: f64];
    let ynorm = ~[b: f64];

    lstm_predict(l, b, main_params, extra_params, state, sequence, ypred);
    let lse = sum(ypred, b);
    lse
}

extern fn print(size: i32, a : &mut [f64]) -> (){
    for i in 0 .. size {
        printDouble(a(i));
        printString("\n");
    }
}

extern fn const(size: i32, a : &mut [f64], value : f64) -> (){
    for i in 0 .. size {
        a(i) = value;
    }
}

fn runGmmBenchmark(file: &[u8]) -> (){

    let mut l: i32;
    let mut c: i32;
    let mut b: i32;

    let mut main_params: &mut[f64];
    let mut extra_params: &mut[f64];
    let mut state: &mut[f64];
    let mut sequence: &mut[f64];


    read_lstm_instance(file, &mut l, &mut c, &mut b, &mut main_params, &mut extra_params, &mut state, &mut sequence);

    let main_sz = 2 * l * 4 * b;
    let extra_sz = 3 * b;
    let state_sz = 2 * l * b;
    let seq_sz = c * b;

    let grad_sz = main_sz + extra_sz + state_sz + seq_sz;
    let mut gradients : &mut[f64] = ~[grad_sz: f64];

    let mut main_params_d: &mut[f64] = gradients;
    let mut extra_params_d: &mut[f64] = &main_params_d(main_sz) as &mut[f64];
    let mut state_d: &mut[f64] = &extra_params_d(extra_sz) as &mut[f64];
    let mut sequence_d: &mut[f64] = &state_d(state_sz) as &mut[f64];

    const(main_sz, main_params_d, 0.0);
    const(extra_sz, extra_params_d, 0.0);
    const(state_sz, state_d, 0.0);
    const(seq_sz, sequence_d, 0.0);

    //let fx = lstm(l, c, b, main_params, extra_params, state, sequence);

    let diff = rev_diff(lstm);
    begin();
    let (fx, backward) = diff(l, c, b, main_params, main_params_d, extra_params, extra_params_d, state, state_d, sequence, sequence_d);
    let result = backward(1.0);
    eval();


    printString("extra_params_d\n");
    print(extra_sz, extra_params_d);
    printString("\n");
    printDouble(fx);


    //printDouble(loss);
}

fn main(argc: i32,argv :&[&[u8]]) -> i32 {
    if argc < 2{
        printString("No Benchmark specified");
    }else{
        let file = argv(1);
        printString(file);
        runGmmBenchmark(file);
    }

    0
}





