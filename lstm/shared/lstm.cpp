// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.

/*
 *   File "lstm_b_tapenade_generated.c" is generated by Tapenade 3.14 (r7259) from this file.
 *   To reproduce such a generation you can use Tapenade CLI
 *   (can be downloaded from http://www-sop.inria.fr/tropics/tapenade/downloading.html)
 *
 *   After installing use the next command to generate a file:
 *
 *      tapenade -b -o lstm_tapenade -head "lstm_objective(loss)/(main_params extra_params)" lstm.c
 *
 *   This will produce a file "lstm_tapenade_b.c" which content will be the same as the content of the file "lstm_b_tapenade_generated.c",
 *   except one-line header. Moreover a log-file "lstm_tapenade_b.msg" will be produced.
 *
 *   NOTE: the code in "lstm_b_tapenade_generated.c" is wrong and won't work.
 *         REPAIRED SOURCE IS STORED IN THE FILE "lstm_b.c".
 *         You can either use diff tool or read "lstm_b.c" header to figure out what changes was performed to fix the code.
 *
 *   NOTE: you can also use Tapenade web server (http://tapenade.inria.fr:8080/tapenade/index.jsp)
 *         for generating but the result can be slightly different.
 */
#include "lstm.h"
#include <iostream>

// UTILS
// Sigmoid on scalar
double sigmoid(double x)
{
    return 1.0 / (1.0 + exp(-x));
}

// log(sum(exp(x), 2))
double logsumexp(double const*  __restrict__ vect, int sz)
{
    double sum = 0.0;
    int i;

    for (i = 0; i < sz; i++)
    {
        sum += exp(vect[i]);
    }

    sum += 2;
    return log(sum);
}

double sum(double const*  __restrict__ vect, int sz)
{
    double sum = 0.0;

    for (int i = 0; i < sz; i++)
    {
        sum += (vect[i]);
    }

    return sum;
}

// LSTM OBJECTIVE
// The LSTM model
void lstm_model(
    int hsize,
    double const* weight,
    double const* bias,
    double*  __restrict__ hidden,
    double*  __restrict__ cell,
    double const*  __restrict__ input
)
{
    for (int i = 0; i < hsize; i++)
    {
        auto forget = sigmoid(input[i] * weight[i] + bias[i]);
        auto ingate = sigmoid(hidden[i] * weight[hsize + i] + bias[hsize + i]);
        auto outgate = sigmoid(input[i] * weight[2 * hsize + i] + bias[2 * hsize + i]);
        auto change = tanh(hidden[i] * weight[3 * hsize + i] + bias[3 * hsize + i]);

        cell[i] = cell[i] * forget + ingate * change;
        hidden[i] = outgate * tanh(cell[i]);
    }
}

// Predict LSTM output given an input
//l, b, main_params, extra_params, state, input, ypred
void lstm_predict(
    int l,
    int b,
    double const*  __restrict__ w, //main_params
    double const*  __restrict__ w2, // extra_params
    double*  __restrict__ s, //state
    double const*  __restrict__ x, //input
    double*  __restrict__ x2
)
{
    int i;
    for (i = 0; i < b; i++)
    {
        x2[i] = x[i] * w2[i];
    }

    double* xp = x2;
    for (i = 0; i <= 2 * l * b - 1; i += 2 * b)
    {
        lstm_model(b, &(w[i * 4]), &(w[(i + b) * 4]), &(s[i]), &(s[i + b]), xp);
        xp = &(s[i]);
    }

    for (i = 0; i < b; i++)
    {
        x2[i] = xp[i] * w2[b + i] + w2[2 * b + i];
    }
}

// LSTM objective (loss function)
void lstm_objective(
    int l,
    int c,
    int b,
    double const*  __restrict__ main_params,
    double const*  __restrict__ extra_params,
    double*  __restrict__ state,
    double const*  __restrict__ sequence,
    double*  __restrict__ loss
)
{
    double total = 0.0;
    double* ypred = (double*)malloc(b * sizeof(double));
    double* ynorm = (double*)malloc(b * sizeof(double));
    const double* ygold;
    double lse;

    lstm_predict(l, b, main_params, extra_params, state, &(sequence[0]), ypred);
    lse = logsumexp(ypred, b);
    for (int i = 0; i < b; i++)
    {
        ynorm[i] = ypred[i] - lse;
    }

    for (int i = 0; i < b; i++)
    {
        total += sequence[i + b] * ynorm[i];
    }

    for (int i = 1; i < c - 1; i++)
    {
        int t = i * b;
        int t_last = (i - 1) * b;
        lstm_predict(l, b, main_params, extra_params, state, &(sequence[t_last + b]), ypred);
        lse = logsumexp(ypred, b);
        for (int i = 0; i < b; i++)
        {
            ynorm[i] = ypred[i] - lse;
        }

        for (int i = 0; i < b; i++)
        {
            total += sequence[t + b + i] * ynorm[i];
        }
    }

    *loss = -total / ((c - 1) * b);
free(ypred);
    free(ynorm);
}



void read_lstm_instance(const std::string& fn,
                        int* l, int* c, int* b,
                        std::vector<double>& main_params,
                        std::vector<double>& extra_params,
                        std::vector<double>& state,
                        std::vector<double>& sequence)
{
    FILE* fid = fopen(fn.c_str(), "r");

    if (!fid) {
        printf("could not open file: %s\n", fn.c_str());
        exit(1);
    }

    fscanf(fid, "%i %i %i", l, c, b);

    int l_ = *l, c_ = *c, b_ = *b;

    int main_sz = 2 * l_ * 4 * b_;
    int extra_sz = 3 * b_;
    int state_sz = 2 * l_ * b_;
    int seq_sz = c_ * b_;

    main_params.resize(main_sz);
    extra_params.resize(extra_sz);
    state.resize(state_sz);
    sequence.resize(seq_sz);

    for (int i = 0; i < main_sz; i++) {
        fscanf(fid, "%lf", &main_params[i]);
    }

    for (int i = 0; i < extra_sz; i++) {
        fscanf(fid, "%lf", &extra_params[i]);
    }

    for (int i = 0; i < state_sz; i++) {
        fscanf(fid, "%lf", &state[i]);
    }

    for (int i = 0; i < c_ * b_; i++) {
        fscanf(fid, "%lf", &sequence[i]);
    }

    fclose(fid);
}