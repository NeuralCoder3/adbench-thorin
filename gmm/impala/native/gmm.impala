extern "C" {
    fn printString(&[u8]) -> ();
    fn printLine(&[u8]) -> ();
    fn printFloat(f32) -> ();
    fn printDouble(f64) -> ();
    fn printInteger(i32) -> ();
    fn log(f64) -> (f64);
    fn exp(f64) -> (f64);
    fn sqrt(f64) -> (f64);
    fn logf(f32) -> (f32);
    fn lgamma(f64) -> (f64);
    fn malloc(i64) -> (&mut[f64]);
    fn read_gmm_size(
        file: &[u8],
        d: &mut i32,
        k: &mut i32,
        n: &mut i32
    ) -> ();
    fn read_gmm(
        file: &[u8],
        d: &mut i32,
        k: &mut i32,
        n: &mut i32,
        wishartM: &mut i32,
        wishartGamma: &mut f64,
        alphas: &mut[f64],
        means: &mut[f64],
        icf: &mut[f64],
        x: &mut[f64],
    ) -> ();
}


fn range(mut b: i32, e: i32, body: fn(i32) -> ()) -> () {
    while b < e {
        body(b++)
    }
}

fn print_vector(m : tn[1:f64]) -> (){
    printLine("----");
    for row in range(0, m.shape as u32){
        printString("|");
        printDouble(m(row as u64));

        printLine("|");
    }
    printLine("----");
}

fn print_matrix(m : tn[2:f64]) -> (){
    printLine("----");
    for row in range(0, m.shape(0) as u32){
        printString("|");
        for col in range(0 , m.shape(1) as u32){
            let value = m(row as u64,col as u64);
            if value >= 0.0{
                printString("");
            }
            printDouble(value);
        }

        printLine("|");
    }
    printLine("----");
}

fn sqr(x:f64) -> f64{
    x * x
}

fn print_tensor(m : tn[3:f64]) -> (){
    printLine("####");
    for index in range(0, m.shape(0) as u32){
        printLine("----");
        for row in range(0, m.shape(1) as u32){
            printString("|");
            for col in range(0 , m.shape(2) as u32){
                let value = m(index as u64,row as u64,col as u64);
                if value >= 0.0{
                    printString("");
                }
                printDouble(value);
            }

            printLine("|");
        }
        printLine("----");
    }
    printLine("####");
}

/*
fn gmm(){
    xcentered = torch.stack(tuple( x[i] - means for i in range(n) )) #no
}*/

fn log_gamma_distrib( a: f64, p: i32, f: tn[1: f64] ) -> f64
{
    let PI : f64 = 3.14159265359;

    let sub_res = tn.formula("{} - {i} -> {i}", a, f);
    let lgamma_res = sub_res.map(lgamma);
    let sum = lgamma_res.sum;

    0.25 * ((p * (p - 1)) as f64) * log(PI) + sum
}

fn log_wishart_prior(d: i32, wishart_gamma: f64, wishart_m: i32, sum_qs: tn[1: f64], Qdiags: tn[2: f64], icf: tn[3: f64], f: tn[1 : f64] ) -> (f64){

    let n = d + wishart_m + 1;

    let k = icf.shape(0);

    printInteger(n);

    let Qdiags_sqr = Qdiags.map(sqr);
    let icf_sqr = icf.map(sqr);

    let Qdiags_sqr_sum = tn.formula("{ij} -> {i}", Qdiags_sqr);
    let icf_sqr_sum = tn.formula("{ijk} -> {i}", icf_sqr);

    let out = (
        0.5 * wishart_gamma * wishart_gamma *
        (Qdiags_sqr_sum + icf_sqr_sum) - (wishart_m as f64) * sum_qs
    ).sum;

    let C = ((n * d) as f64) * (log(wishart_gamma / sqrt(2.0)));
    out - (k as f64) * (C  - log_gamma_distrib(0.5 * (n as f64), d, f))
}

fn logsumexpvec(x : tn[2: f64]) -> tn[1: f64]{

    let mx{}, indices: max(i), sum(i) = x{i,j}

    let mx = x.maxLast;

    let diff = tn.formula("{ij} - {i}-> {ji}", x, mx);

    let exp_res = diff.map(exp);
    let sum_res = tn.formula("{ij} -> {j}", exp_res);
    let log_res = sum_res.map(log);
    let logsumexp_res = log_res + mx;
    logsumexp_res
}

fn logsumexp(x : tn[1: f64]) -> f64{
    let mx2 = x.max;
    //let diff2 = tn.formula("{i} - {}-> {i}", x, mx2);
    let diff2 = x - mx2;
    let emx = diff2.map(exp);
    let sum_res2 = emx.sum;
    let logsumexp_res2 = log(sum_res2) + mx2;
    logsumexp_res2
}

fn gmm(d: i32, k: i32, n: i32,
        wishartGamma: f64,
        wishartM: i32,
        alphas : tn[1:f64],
        means : tn[2:f64],
        diag : tn[2:f64],
        tri : tn[3:f64],
        x : tn[2:f64],
        factor: tn[1:f64]) -> f64{

    let Qdiags = diag.map(exp);
    let sum_qs = tn.formula("{ij} -> {i}", diag);

    let xcentered = tn.formula("{ij} - {kj} -> {ikj}", x, means);
    let f1 = tn.formula("{ijk} * {mik} -> {mij}", tri, xcentered);
    let f2 = tn.formula("{jk} * {ijk} -> {ijk}", Qdiags, xcentered);
    let Lxcentered = f1 + f2;
    let Lxcentered_sq = Lxcentered.map(sqr);
    let sqsum_Lxcentered = tn.formula("{ijk} -> {ij}", Lxcentered_sq);

    let alpha_sumqs = alphas + sum_qs;
    let inner_term = tn.formula("{j} - {ij} -> {ij}", alpha_sumqs, 0.5 * sqsum_Lxcentered);

    let lse = logsumexpvec(inner_term);
    let logsumexp_res = logsumexp(alphas);

    let slse = lse.sum;

    let prior = log_wishart_prior(d, wishartGamma, wishartM, sum_qs, Qdiags, tri, factor);

    let CONSTANT = -((n * d) as f64) * 0.5 * log(2.0 * 3.14159265359);
    let result = CONSTANT + slse - (n as f64) * logsumexp_res + prior;

    result
}


fn runGmmBenchmark(file: &[u8]) -> (){
    let mut d = 2;
    let mut k = 5;
    let mut n = 1000;

    let dp = &mut d;
    let kp = &mut k;
    let np = &mut n;

    read_gmm_size(file, dp, kp, np);

    let mut wishartM: i32 = 0;
    let mut wishartGamma: f64 = 1.0;

    let icf_size = ( d * (d + 1) / 2 );

    let alphas = tn[f64](k);
    let means = tn[f64](k, d);
    let icf = tn[f64](k, icf_size);
    let x = tn[f64](n, d);

    read_gmm(file, dp, kp, np, &mut wishartM, &mut wishartGamma, &alphas(0) as &mut[f64], &means(0,0) as &mut[f64], &icf(0,0) as &mut[f64], &x(0,0) as &mut[f64]);

    let diag = tn[f64](k, d);
    let tri = tn[f64](k, d, d);

    for n_index in range(0, n){
        for d_index in range(0, d){
            diag(n_index, d_index) = icf(n_index, d_index)
        }
    }


    for n_index in range(0, n){
        let mut icf_index = d;
        for icf_col_index in range(0, d){
            for icf_row_index in range(0, d){
                let mut value : f64;
                if(icf_col_index < icf_row_index){
                    value = icf(n_index, icf_index++);
                }else{
                    value = 0.0;
                }

                tri(n_index, icf_row_index, icf_col_index) = value;
            }
        }
    }

    let factor = tn[f64](d);
    for j in range(0, d){
        factor(j) = 0.5 * (j as f64);
    }


   let result = gmm(d,k,n,wishartGamma, wishartM, alphas, means, diag, tri, x, factor);
       printDouble(result);

/*
    let diff = rev_diff(gmm);

    let (fx,pb) = diff(d, k, n, wishartGamma, wishartM, alphas, means, diag, tri, x, factor);
    let gradients = pb(1.0);
     let alphas_d = gradients(5);
    let means_d = gradients(6);
    let diag_d = gradients(7);
    let tri_d = gradients(8);

    print_vector(alphas_d);*/


/*
    let result = gmm(d, k, n, wishartGamma, wishartM, alphas, means, icf, x);

    let diff = rev_diff(gmm);

    let (y,pb) = diff(d, k, n, wishartGamma, wishartM, alphas, means, icf, x);
    let gradients = pb(1.0);
    let alphas_d = gradients(5);
    let means_d = gradients(6);
    let icf_d = gradients(7);
*/

    printDouble(alphas(0));
}


fn main(argc: i32,argv :&[&[u8]]) -> i32 {
    if argc < 2{
        printString("No Benchmark specified");
    }else{
        let file = argv(1);
        printString(file);
        runGmmBenchmark(file);
    }

    0
}


