extern "C" {
    fn printString(&[u8]) -> ();
    fn printFloat(f32) -> ();
    fn printDouble(f64) -> ();
    fn printInteger(i32) -> ();
    fn log(f64) -> (f64);
    fn exp(f64) -> (f64);
    fn logf(f32) -> (f32);
    fn lgamma(f64) -> (f64);
    fn malloc(i64) -> (&mut[f64]);
    fn read_gmm_size(
        file: &[u8],
        d: &mut i32,
        k: &mut i32,
        n: &mut i32
    ) -> ();
    fn read_gmm(
        file: &[u8],
        d: &mut i32,
        k: &mut i32,
        n: &mut i32,
        wishartM: &mut i32,
        wishartGamma: &mut f64,
        alphas: &mut[f64],
        means: &mut[f64],
        icf: &mut[f64],
        x: &mut[f64],
    ) -> ();
}


fn range(mut b: i32, e: i32, body: fn(i32) -> ()) -> () {
    while b < e {
        body(b++)
    }
}

fn subtract(args : [(
        i32, //d
        &[f64], //x
        i32, //x_offset
        &[f64], //y
        i32, //y_offset
        &mut[f64], //out
    )*2]
) -> f32
{
    let arg = args(0);
    let d = arg(0);
    let x = arg(1);
    let x_offset = arg(2);
    let y = arg(3);
    let y_offset = arg(4);
    let out = arg(5);

    let mut id = 0;
    while id < d {
        out(id) = x(id + x_offset) - y(id + y_offset);
        id++;
    }
    0f
}

fn Qtimesx(args : [(
        i32, //d
        &[f64],//Qdiag
        i32, //Qdiag_offset
        &[f64],//ltri
        i32, //ltri_offset
        &[f64],//x
        &mut[f64],//out
    )*2]
) -> f32
{
    let arg = args(0);
    let d = arg(0);
    let Qdiag = arg(1);
    let Qdiag_offset = arg(2);
    let ltri = arg(3);
    let ltri_offset = arg(4);
    let x = arg(5);
    let out = arg(6);

    let mut id = 0;
    while id < d {
        out(id) = Qdiag(id + Qdiag_offset) * x(id);
        id++;
    }

    let mut Lparamsidx = 0;

    let mut i = 0;
    while i < d {
        let mut j = i + 1;
        while j < d {
            out(j) = out(j) + ltri(Lparamsidx + ltri_offset) * x(i);
            Lparamsidx++;
            j++;
        }
        i++;
    }
    0f
}

fn sqnorm(args : [(
        i32,
        &[f64],
        i32,
    )*2]
) -> f64
{
    let arg = args(0);
    let d = arg(0);
    let v = arg(1);
    let offset = arg(2);

    let mut sum = 0.0;
    let mut i = 0;
    while i < d{
        let val = v(i + offset);
        sum += val * val;
        i++;
    }

    sum
}

fn arr_max(args : [(
        i32,
        &[f64],
    )*2]
) -> f64
{
    let arg = args(0);
    let n = arg(0);
    let x = arg(1);

    let mut m = x(0);
    /*let mut i = 1;
    while i < n {
        if (m < x(i)){
            m = x(i);
        }
        i++;
    }*/

    m
}

fn logsumexp(args : [(
        i32,
        &[f64],
    )*2]
) -> f64
{
    let arg = args(0);
    let n = arg(0);
    let x = arg(1);

    let max_tup = (n, x);
    let mx = arr_max([max_tup, max_tup]);
    let mut semx = 0.0;
    let mut i = 0;
    while i < n {
        semx += exp(x(i) - mx);
        i++;
    }
    log(semx) + mx
}

fn log_gamma_distrib(args : [(
        f64,
        i32,
    )*2]
) -> f64
{
    let arg = args(0);
    let a = arg(0);
    let p = arg(1);

    let mut out = 0.25 * ((p * (p - 1)) as f64) * log(3.14159265359);

    let mut j = 1;
    while j < p+1 {
        out += lgamma(a + 0.5 * ((1 - j) as f64));
        j++;
    }

    out
}


fn log_wishart_prior(
    args:[(
        i32, //p
        i32, //k
        f64, //wishartGamma
        i32, //wishartM
        &[f64], // sum_qs
        &[f64], // Qdiags
        &[f64], // icf
    )*2]
) -> f64{
    let arg = args(0);
    let p: i32 = arg(0);
    let k: i32 = arg(1);
    let wishartGamma: f64 = arg(2);
    let wishartM: i32 = arg(3);
    let sum_qs: &[f64] = arg(4);
    let Qdiags: &[f64] = arg(5);
    let icf: &[f64] = arg(6);

    let n = p + wishartM + 1;
    let icf_sz = p * (p + 1) / 2;

    let distrb_tuble = (0.5 * (n as f64), p);
    let C = (n as f64) * (p as f64) * (log(wishartGamma) - 0.5 * log(2.0)) - log_gamma_distrib([distrb_tuble,distrb_tuble]);

    let mut out = 0.0;

    let mut ik = 0;
    while ik < k {
        let p_offset = ik * p;
        let icf_offset = ik * icf_sz + p;

        let sqnorm_tup = (p, Qdiags, p_offset);
        let sqnorm_tup2 = (icf_sz - p, icf, icf_offset);
        let frobenius = sqnorm([sqnorm_tup, sqnorm_tup]) + sqnorm([sqnorm_tup2, sqnorm_tup2]);
        out += 0.5 * wishartGamma * wishartGamma * frobenius - (wishartM as f64) * sum_qs(ik);
        ik++;
    }

    out - (k as f64) * C
}



fn preprocess_qs( d: i32, k: i32,
    /*icf : &[f64],*/
    sum_qs : &mut[f64],
    Qdiags : &mut[f64]) -> ()
{
/*
    let icf_sz = d * (d + 1) / 2;

    let mut ik = 0;
    while ik < k {
        sum_qs(ik) = 0.0;

        let mut id = 0;
        while id < d {
            let q = icf(ik * icf_sz + id);
            sum_qs(ik) = sum_qs(ik) + q;
            Qdiags(ik * d + id) = exp(q);
            id++;
        }
        ik++;
    }*/
}

fn gmm(d: i32, k: i32, n: i32,
        wishartGamma: f64,
        wishartM: i32,
        alphas : &[f64],
        means : &[f64],
        icf : &[f64],
        x : &[f64]) -> f64{


    let CONSTANT = -(n as f64) * ( d as f64) * 0.5 * log(2.0 * 3.14159265359);
    let icf_sz = d * (d + 1) / 2;

    let Qdiags : &mut[f64] = ~[2*5:f64];
    let sum_qs : &mut[f64] = ~[5:f64];
    let xcentered : &mut[f64] = ~[2:f64];
    let Qxcentered : &mut[f64] = ~[2:f64];
    let main_term : &mut[f64] = ~[5:f64];

    //preprocess_qs(d, k/*, icf,*/, sum_qs, Qdiags);


    /*let mut err = 0.0;
    let mut slse = 0.0;
*/
    main_term(0) = 0.0;

    let mut ix = 0;
    //while ix < n {
        //let x_offset = ix * d;
        //let mut ik = 0;
        //while ik < k{
/*
            let d_offset = ik * d;
            let icf_offset = ik * icf_sz + d;

            let subtract_tup = (d, x, x_offset, means, d_offset, xcentered);
            subtract([subtract_tup, subtract_tup]);
            let qtimesx_tup = (d, Qdiags, d_offset, icf, icf_offset, xcentered, Qxcentered);
            Qtimesx([qtimesx_tup, qtimesx_tup]);
            let sqnorm_tup = (d, Qxcentered, 0);
            main_term(ik) = alphas(ik) + sum_qs(ik) - 0.5 * sqnorm([sqnorm_tup, sqnorm_tup]);
            ik++;*/
        //}
        //let lopsum_tup = (k, main_term);
        //slse += logsumexp([lopsum_tup, lopsum_tup]);
        //ix++;
    //}
/*
    let lopsum_tup = (k, alphas);
    let lse_alphas = logsumexp([lopsum_tup, lopsum_tup]);
    //let prior_tup = (d, k, wishartGamma, wishartM, sum_qs, Qdiags, icf);
    err = CONSTANT + slse - (n as f64) * lse_alphas;// + log_wishart_prior([prior_tup, prior_tup]);*/
    alphas(0)
}

fn runGmmBenchmark(file: &[u8]) -> (){
    let mut d = 2;
    let mut k = 5;
    let mut n = 1000;

    let dp = &mut d;
    let kp = &mut k;
    let np = &mut n;

    read_gmm_size(file, dp, kp, np);

    let mut wishartM: i32 = 0;
    let mut wishartGamma: f64 = 1.0;

    let alphas_size = k as u64;
    let means_size = (d*k) as u64;
    let icf_size = (k * ( d * (d + 1) / 2 ))  as u64;
    let x_size = (d*n) as u64;

    let size = alphas_size + means_size + icf_size;

    let alphas: &mut[f64] = ~[k:f64];
    let means: &mut[f64] = ~[d*k:f64];
    let icf: &mut[f64] = ~[k * ( d + d * ( d - 1 ) / 2 ):f64];
    let x: &mut[f64] = ~[x_size:f64];

    let wishartMp = &mut wishartM;
    let wishartGammap = &mut wishartGamma;

    read_gmm(file, dp, kp, np, wishartMp, wishartGammap, alphas, means, icf, x);


    //let result = gmm(d, k, n, wishartGamma, wishartM, (alphas_size, alphas), (means_size, means), (icf_size, icf), (x_size, x));
    //let result = gmm( alphas);

    let Df = rev_diff(gmm);

    let (y,pb) = Df(d, k, n, wishartGamma, wishartM, (alphas_size, alphas), (means_size, means), (icf_size, icf), (x_size, x));
    //let er = Df((alphas_size, alphas));
  /*  let Gf = pb(1.0);
    let arg_deriv=Gf(0);
    let alphas_d=arg_deriv(5);
    let means_d=arg_deriv(6);
    let icf_d=arg_deriv(7);
        printDouble(y);

    */

    //printDouble(result);
}


fn main(argc: i32,argv :&[&[u8]]) -> i32 {
    if argc < 2{
        printString("No Benchmark specified");
    }else{
        let file = argv(1);
        printString(file);
        runGmmBenchmark(file);
    }

    0
}


