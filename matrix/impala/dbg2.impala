extern "C" {
    fn printFloat(f32) -> ();
    fn printDouble(f64) -> ();
    fn printInteger(i32) -> ();
    fn printString(&[u8]) -> ();
    fn log(f64) -> (f64);
    fn exp(f64) -> (f64);
    fn sqrt(f64) -> (f64);
    fn sin(f64) -> (f64);
    fn cos(f64) -> (f64);
    fn logf(f32) -> (f32);
    fn lgamma(f64) -> (f64);
    fn read_ba_size(
        file: &[u8],
        n: &mut i32,
        m: &mut i32,
        p: &mut i32
    ) -> ();
    fn read_ba_instance(
        file: &[u8],
        n: i32,
        m: i32,
        p: i32,
        cams: &mut[f64],
        X: &mut[f64],
        w: &mut[f64],
        obs: &mut[i32],
        feats: &mut[f64]
    ) -> ();
    fn compute_reproj_error_d(
        cams: &[f64],
        X: &[f64],
        w: f64,
        feat_x: f64,
        feat_y: f64,
        err: &mut[f64],
        J: &mut[f64],
    ) -> ();

    fn ba_objective(
        n: i32,
        m: i32,
        p: i32,
        cams: &[f64],
        X: &[f64],
        w: &[f64],
        obs: &[i32],
        feats: &[f64],
        reproj_err: &mut[f64],
        w_err: &mut[f64]) -> ();
}

fn cross(
    a : &[f64],
    b : &[f64],
    out : &mut[f64]) -> ()
{
    out(0) = a(1) * b(2) - a(2) * b(1);
    out(1) = a(2) * b(0) - a(0) * b(2);
    out(2) = a(0) * b(1) - a(1) * b(0);
}


fn sqsum( n: i32, x : &[f64]) -> (f64)
{
    let mut res = 0.0;
    for i in 0 .. n {
        res = res + x(i) * x(i);
    }

    res
}


fn rodrigues_rotate_point(
    rot: &[f64],
    pt: &[f64],
    rotatedPt : &mut[f64]) -> ()
{
    let sqtheta = sqsum(3, rot);
    if (sqtheta != 0.0)
    {
        let mut w : [f64 * 3];
        let mut w_cross_pt : [f64 * 3];

        let theta = sqrt(sqtheta);
        let costheta = cos(theta);
        let sintheta = sin(theta);
        let theta_inverse = 1.0 / theta;

        for i in 0 .. 3 {
            w(i) = rot(i) * theta_inverse;
        }


        cross(w, pt, &w_cross_pt as &mut[f64]);


        for i in 0 .. 3 {
            rotatedPt(i) = w_cross_pt(i);
        }

/*
        let tmp = (w(0) * pt(0) + w(1) * pt(1) + w(2) * pt(2)) *
            (1.0 - costheta);

        for i in 0 .. 3 {
            rotatedPt(i) = pt(i) * costheta + w_cross_pt(i) * sintheta + w(i) * tmp;
        }*/
    }
    else
    {
    /*
        let mut rot_cross_pt : [f64 * 3];
        cross(rot, pt, &rot_cross_pt as &mut[f64]);

        for i in 0 .. 3 {
            rotatedPt(i) = pt(i) + rot_cross_pt(i);
        }*/
    }
}


fn radial_distort(
    rad_params : &[f64],
    proj: &mut[f64]) -> ()
{
    let rsq = sqsum(2, proj);
    let L = 1.0 + rad_params(0) * rsq + rad_params(1) * rsq * rsq;
    proj(0) = proj(0) * L;
    proj(1) = proj(1) * L;
}


fn project(cam: &[f64], X: &[f64], proj: &mut[f64]) -> (){

    let C =  &cam(3) as &[f64];
    let mut Xo : [f64 * 2];
    let mut Xcam : [f64 * 3];

    Xo(0) = X(0) - C(0);
    Xo(1) = X(1) - C(1);
    Xo(2) = X(2) - C(2);

    rodrigues_rotate_point(&cam(0) as &[f64], &Xo as &mut[f64], &Xcam as &mut[f64]);

    proj(0) = Xcam(0) / Xcam(2);
    proj(1) = Xcam(1) / Xcam(2);

    radial_distort(&cam(9) as &[f64], proj);

    proj(0) = proj(0) * cam(6) + cam(7);
    proj(1) = proj(1) * cam(6) + cam(8);
}



fn computeReprojError(cam: &[f64], X: &[f64], w: f64, feats: &[f64], err: &mut[f64]) -> (){
    let mut proj : [f64 * 2];
    project(cam, X, &proj as &mut[f64]);

    err(0) = w * (proj(0) - feats(0));
    err(1) = w * (proj(1) - feats(1));
}



fn computeZachWeightError(w: f64) -> (f64)
{
    1.0 - w * w
}

extern fn print(size: i32, a : &mut [f64]) -> (){
    for i in 0 .. size {
        printDouble(a(i));
        printString("\n");
    }
}

extern fn constDouble(size: i32, a : &mut [f64], value : f64) -> (){
    for i in 0 .. size {
        a(i) = value;
    }
}

extern fn constInt(size: i32, a : &mut [i32], value : i32) -> (){
    for i in 0 .. size {
        a(i) = value;
    }
}

fn ba(n: i32, m: i32, p: i32, cams: &[f64], X: &[f64], w: &[f64], obs: &[i32], feats: &[f64], reproj_err: &mut[f64], w_err: &mut[f64]) -> (){

    for i in 0  .. p
    {
        let camIdx = obs(i * 2 + 0);
        let ptIdx = obs(i * 2 + 1);
        computeReprojError(
            &cams(camIdx * 11)  as &[f64],
            &X(ptIdx * 3)  as &[f64],
            w(i),
            &feats(i * 2) as &[f64],
            &reproj_err(2 * i) as &mut[f64]
        );
    }

    for i in 0 .. p
    {
        w_err(i) = computeZachWeightError(w(i));
    }
}

fn runGmmBenchmark(file: &[u8]) -> (){

    let mut n = 2;
    let mut m = 5;
    let mut p = 1000;

    read_ba_size(file, &mut n, &mut m, &mut p);

    let nCamParams = 11;

    let cams = ~[nCamParams * n:f64];
    let X = ~[3 * m:f64];
    let w = ~[p:f64];
    let obs = ~[2 * p:i32];
    let feats = ~[2 * p:f64];

    let reproj_err = ~[2 * p:f64];
    let w_err = ~[p:f64];

    read_ba_instance(file, n, m, p, cams, X, w, obs, feats);

    let cams_d = ~[nCamParams * n:f64];
    let X_d = ~[3 * m:f64];
    let w_d = ~[p:f64];
    let obs_d = ~[2 * p:i32];
    let feats_d = ~[2 * p:f64];
    let reproj_err_d = ~[2 * p:f64];
    let w_err_d = ~[p:f64];

    constDouble(nCamParams * n, cams_d, 0.0);
    constDouble(3 * m, X_d, 0.0);
    constDouble(p, w_d, 0.0);
    constInt(2 * p, obs_d, 0);
    constDouble(2 * p, feats_d, 0.0);
    constDouble(2 * p, reproj_err_d, 1.0);
    constDouble(p, w_err_d, 1.0);

    printInteger(n);
    printInteger(m);
    printInteger(p);
    printDouble(cams(0));

    //ba(n, m, p, cams, X, w, obs, feats, reproj_err, w_err);

    printDouble(w_err(0));
    printDouble(w_err(1));
    printDouble(w_err(2));

    let diff = rev_diff(ba);
    let backward = diff(n, m, p, cams, cams_d, X, X_d, w, w_d, obs, obs_d, feats, feats_d, reproj_err, reproj_err_d, w_err, w_err_d);
    backward();

    printString("\ncams gradients: \n");
    print(20, cams_d);

/*

    ba_objective(n, m, p, cams, X, w, obs, feats, reproj_err, w_err);

    let J = ~[2 * (nCamParams + 3):f64];

    for i in 0 .. p {
        let camIdx = obs(2 * i);
        let ptIdx = obs(2 * i + 1);

        let currentCams =  &cams(nCamParams * camIdx) as &[f64];
        let currentX =  &X(nCamParams * camIdx) as &[f64];
        let currentW = w(i);
        let feat_x = feats(2 * i);
        let feat_y = feats(2 * i + 1);
        let current_reproj_err =  &reproj_err(2 * i) as &mut[f64];

        compute_reproj_error_d(currentCams, currentX, currentW, feat_x, feat_y, current_reproj_err, J );
    }


    for i in 0 .. p {
        let mut w_err = 0.0;
        let mut w_d = 0.0;
        compute_zach_weight_error_d(w(i), &mut w_err, &mut w_d);

        printDouble(w_err);
        printDouble(w_d);
    }*/

}

fn main() -> i32 {
    runGmmBenchmark("../benchmark/ba/ba1_n49_m7776_p31843.txt");
    0
}

